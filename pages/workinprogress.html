---
permalink: /workinprogress
---
{% include header.html %}
<pre><code>def addDataPoint(self, clickmap: List[Tuple[float, float]], dist: int):  # IT LEARNS
    if dist > self.bestdist:
        self.curset: List[Tuple[float, float]] = clickmap[::len(clickmap) - 1]
    else:
        pass
        for i, datapoint in enumerate(clickmap[::math.floor(len(clickmap) * 0.9)]):  # ignores the last item its fine
            self.curset[i] = (statistics.fmean([datapoint[0], self.curset[i][0], self.curset[i][0]]), statistics.fmean([datapoint[1], self.curset[i]]))
            # takes average of last 90% of data, old data is twice as weighted
        # refine current clickmap based on death location
    self.trialset = []
    for i in range(math.floor(len(self.curset) * 0.5), len(self.curset)):
        self.trialset.append(((random.randint(99, 101)/100) * self.curset[i][0], (random.randint(99, 101)/100) * self.curset[i][1]))</code></pre>
<p>This code allows that allows the program to "learn" from its past mistakes and refine the timings it should click at.
    Constructed while at a computer science camp I wanted to make a program learn specifc timings, but I never had time to finish it.
</p>